Основное правило системы типов TypeScript таково — `x` совместимо с `y`, если `y` имеет по крайней мере те же самые члены, что и `x`. Наример:

```ts
interface Named {
    name: string;
}

let x: Named;
// выведенный тип для y — { name: string; location: string; }
let y = { name: "Alice", location: "Seattle" };
x = y;
```

Чтобы понять, может ли `y` быть присвоена `x`, компилятор для каждого из свойств `x` ищет соответствующее совместимое свойство в `y`. В данном случае переменная `y` должна иметь свойство под именем `name` строкового типа. Оно есть, и присваивание допускается.

То же правило используется в случае проверки аргументов при вызове функции:

```ts
function greet(n: Named) {
    alert("Привет, " + n.name);
}
greet(y); // ОК
```

Обратите внимание, что `y` обладает дополнительным свойством `location`, но это не приводит к ошибке. При проверке на совместимость учитываются только члены целевого типа (в данном случае это `Named`).

Процесс сравнения производится рекурсивно, затрагивая типы всех членов и подчленов.


## Сравнение двух функций

Сравнение типов двух примитивов или объектов происходит относительно просто, однако вопрос о том, какие функции должны считаться совместимыми, немного более сложен. Начнем с простого примера с двумя функциями, отличающимися только списками параметров:

```ts
let x = (a: number) => 0;
let y = (b: number, s: string) => 0;

y = x; // Все нормально
x = y; // Ошибка
```

Чтобы проверить, допустимо ли присваивание x к y, сначала просматривается список параметров. Для каждого параметра функции x у функции y должен быть соответствующий параметр совместимого типа. Имена параметров не принимаются во внимание — важны лишь типы. В данном случае для каждого параметра x есть соответствующий совместимый параметр в функции y, поэтому присваивание допускается.

Второе присваивание приводит к ошибке, поскольку y имеет обязательный второй параметр, которого нет у x, и операция не допускается.

Может показаться интересным, почему разрешается "терять" параметры функции, как это происходит при y = x. Причина этому то, что игнорирование лишних параметров функции — довольно частая практика в JavaScript. К примеру, Array#forEach передает функции обратного вызова три параметра: элемент массива, его индекс, и массив, в котором тот содержится. Несмотря на это, очень удобно работать с функцией обратного вызова, которая использует лишь первый параметр:

```ts
let items = [1, 2, 3];

// Не заставлять использовать дополнительные параметры
items.forEach((item, index, array) => console.log(item));

// Все должно работать!
items.forEach(item => console.log(item));
```

Теперь посмотрим, как обрабатываются типы возвращаемых значений. Для этого используем две функции, отличающиеся только типами возвращаемых значений:

```ts
let x = () => ({name: "Alice"});
let y = () => ({name: "Alice", location: "Seattle"});

x = y; // Работает
y = x; // Ошибка, поскольку у x() нет свойства location
```

Необходимо, чтобы тип возвращаемого значения исходной функции был подтипом типа возвращаемого значения целевой функции.

### Бивариантность параметров функции

При сравнении типов параметров присваивание допускается, если параметр исходной функции может быть присвоен параметру целевой функции, или наоборот. Это не является надежным, поскольку код может получить функцию, которая принимает более специализированный тип, и передать ей значение менее специализированного типа. На практике такого рода ошибки редки, а допущение подобного позволяет использовать многие распространенные практики из JavaScript. Краткий пример:

```ts
enum EventType { Mouse, Keyboard }

interface Event { timestamp: number; }
interface MouseEvent extends Event { x: number; y: number }
interface KeyEvent extends Event { keyCode: number }

function listenEvent(eventType: EventType, handler: (n: Event) => void) {
    /* ... */
}

// Ненадежно, но полезно и часто используется
listenEvent(EventType.Mouse, (e: MouseEvent) => console.log(e.x + "," + e.y));

// Альтернативы, нежелательные из-за ненадежности
listenEvent(EventType.Mouse, (e: Event) => console.log((<mouseevent>e).x + "," + (<mouseevent>e).y));
listenEvent(EventType.Mouse, <(e: Event) => void>((e: MouseEvent) => console.log(e.x + "," + e.y)));

// Не допускается (явная ошибка). Требуется безопасность типов для полностью несовместимых типов
listenEvent(EventType.Mouse, (e: number) => console.log(e));
</mouseevent></mouseevent>
```

### Опциональные и остаточные параметры

При проверке функций на совместимость опциональные и обязательные параметры взаимозаменяемы. Лишние опциональные параметры исходного типа не приводят к ошибке, так же как и опциональные параметры целевого типа, для которых нет соответствующих параметров.

Когда у функции есть остаточный параметр, он расценивается так, словно представляет собой бесконечное число опциональных параметров.

С точки зрения системы типов это не является надежным, но с точки зрения выполняющегося кода сами опциональные параметры, как правило, не являются чем-то четко определенным, поскольку для большинства функций они эквивалентны передаче undefined.

В пример полезности этого приведем распространенный прием — функцию, которая принимает функцию обратного вызова и вызывает ее с некоторым предсказуемым (для разработчика), но неизвестным (для системы типов) числом аргументов:

```ts
function invokeLater(args: any[], callback: (...args: any[]) => void) {
    /* ... Вызвать функцию в аргументами `args` ... */
}

// Ненадежно — invokeLater может получить любое число аргументов
invokeLater([1, 2], (x, y) => console.log(x + ", " + y));

// Сбивает с толку (x и y на самом деле необходимы), и незаметно
invokeLater([1, 2], (x?, y?) => console.log(x + ", " + y));
```

## Функции с перегрузками

Когда у функции есть перегрузки, для каждой из перегрузок исходного типа у целевого типа должна найтись совместимая сигнатура. Это гарантирует, что целевая функция может быть вызвана в каждой из тех ситуаций, в которых может быть вызвана исходная функция.

## Перечисления

Перечисления совместимы с числами, а числа совместимы с перечислениями. Значения из различных перечислений считаются несовместимыми друг с другом. К примеру,

```ts
enum Status { Ready, Waiting };
enum Color { Red, Blue, Green };

let status = Status.Ready;
status = Color.Green;  // ошибка
```