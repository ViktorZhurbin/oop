## Введение

Традиционный JavaScript фокусируется на функциях и наследовании, основанном на прототипах, для разработки многократно используемых компонентов, но этот подход довольно неудобен по сравнению с привычным объектно-ориентированным программированием, где классы наследуют функционал, и объекты строятся из этих классов. Начиная с ECMAScript 2015, также известном как ECMAScript 6, JavaScript программисты смогут создавать приложения, используя этот объектно-ориентированный подход, основанный на классах. В TypeScript этот подход можно применять уже сейчас, и компилировать код в JavaScript, который будет работать на основной массе браузеров и платформ, не дожидаясь следующей версии JavaScript.

## Классы
Давайте рассмотрим простой пример работы с классами:

```ts
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

let greeter = new Greeter("world");
```

Синтаксис должен быть знакомым, если вы уже программировали на C# или Java. Мы объявили новый класс `Greeter`. Этот класс имеет три члена: свойство `greeting`, конструктор, и метод `greet`.

Вы заметили, что когда мы обращаемся к одному из полей класса, мы добавляем перед именем поля `this`. Это означает, что мы получаем доступ к члену класса.

В последней строке мы создаем экземпляр класса `Greeter`, используя `new`. Он вызывает конструктор, что мы определили ранее, создает новый объект, и запускает конструктор для его инициализации.


## Наследование

В TypeScript используются привычные подходы объектно-ориентированного программирования. Конечно, одним из самых фундаментальных подходов в области программирования на основе классов является создание новых классов с помощью наследования.

Давайте посмотрим на пример:

```ts
class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 45) {
        console.log("Galloping...");
        super.move(distanceInMeters);
    }
}

let sam = new Snake("Sammy the Python");
let tom: Animal = new Horse("Tommy the Palomino");

sam.move();
tom.move(34);
```

Этот пример показывает многие возможности наследования TypeScript, такие же, как и в других языках. Здесь мы видим ключевое слово `extends`, используемое для создания подкласса. Классы `Horse` и `Snake` основаны на классе `Animal` и они получают доступ к его возможностям.

В примере показано, как переопределить методы базового класса с помощью методов, которые указаны в подклассе. Классы `Snake` и `Horse` создают метод `move`, который переопределяет метод `move` из класса `Animal`, придавая ему функциональность, специфичную для каждого из классов. Обратите внимание на то, что хотя tom объявлен как `Animal`, его значением является `Horse`, поэтому при вызове `tom.move(34)`, будет вызван переопределенный метод класса `Horse`.

Производные классы, содержащие функции-конструкторы, должны вызывать `super()`, который будет выполнять функцию-конструктор базового класса.

```bash
Slithering...
Sammy the Python moved 5m.
Galloping...
Tommy the Palomino moved 34m.
```
