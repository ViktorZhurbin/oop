https://medium.com/@sergey.bakaev/typescript-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-c718e951da7d


**Вывод типов** (англ. type inference) — возможность компилятора самому логически вывести тип значения у выражения.

Когда тип данных в явном виде не указан, в TypeScript используется автоматический вывод типа.
```js
let x = 3; // x будет иметь тип number.
```

Вывод типа происходит при:
- инициализации переменных
- установке значений по умолчанию
- определении типов возвращаемых функциями значений

В большинстве случаев вывод типа является очевидным и простым. Однако есть некоторые нюансы.

### Наиболее подходящий тип

Когда вывод типа осуществляется на основании нескольких выражений, типы этих выражений будут использоваться для вывода “наиболее подходящего типа” данных.

Рассмотрим пример:
```js
let x = [0, 1, null];
```

Алгоритм вывода наиболее подходящего типа для `x` учитывает тип каждого элемента в массиве и выбирает тип, совместимый со всеми элементами (`(number | null)[]`).

Поскольку наилучший общий тип необходимо выбрать из типов предоставленных элементов, возможна ситуация, когда у типов общая структура, но нет ни одного супер-типа, общего для всех.

```ts
let zoo = [new Rhino(), new Elephant(), new Snake()];
```

Согласно правилу “наиболее подходящего типа” типом переменной zoo будет являться тип (Rhino | Elephant | Snake)[]. В идеале наилучшим общим типом был бы тип `Animal[]`, но элемента с таким типом нет в массиве. В этом случае необходимо явно указывать тип:

```ts
let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];
```

Когда алгоритм не находит наилучший общий тип, используется union array type (`(Rhino | Elephant | Snake)[]`).


### Контекстная типизация
https://medium.com/@sergey.bakaev/typescript-1-5-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%BD%D0%B0%D1%8F-%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-contextual-typing-f6a4f177421a

Как правило, определение типа TypeScript делается “снизу вверх”: от дочерних элементов дерева выражений к его корню. В следующем примере TypeScript определяет, что возвращаемый тип функции `mul` должен быть `number`, путем получения информации о типе снизу вверх в возвращаемом выражении. Т.е. сначала будет определен тип выражения `a * b`, и затем это значение будет передано вверх к корню дерева выражений, коим является возвращаемое функцией значение.

```ts
var result = function mul(a: number, b: number) {
  return a * b;
}
```
Для переменных и параметров без проставленного типа или для значений по умолчанию, TypeScript подставляет тип `any` гарантируя, что компилятору не нужна больше никакая информация о местах вызова функции для определения типа возвращаемого значения.

Однако, в некоторых случаях, вывод типа выражения осуществляется ‘сверху вниз’, из контекста выражения. Это называется контекстной типизацией. Говоря более простым языком, TypeScript определяет тип выражения из типов его аргументов.
```ts
var result = (a: number, b: number) => number;
result = function(a, b) {
  return a * b;
}
```

Контекстная типизация  —  это вывод типа “в обратном направлении”, когда, например, на основе описания типа мы можем сделать догадку о том, каким должен быть тип аргументов функции или ее возвращаемого значения.

```js
window.onmousedown = function(mouseEvent) {
    // Window.onmousedown: (this: Window, ev: MouseEvent) => any
    // mouseEvent: MouseEvent
    // MouseEvent.button: number
    console.log(mouseEvent.button);  //<- Error
};
```
TypeScript будет определять тип выражения, записанного справа от знака равенства исходя из типа функции `Window.onmousedown`, в котором аргумент функции `mouseEvent` имеет тип `MouseEvent`, а свойство `button` имеет тип `number`.

```ts
onmousedown: (this: Window, ev: MouseEvent) => any;
interface MouseEvent extends UIEvent {
  readonly altKey: boolean;
  readonly button: number;
  ...
}
```

 Если бы функция не находилась в позиции контекстной типизации, у `mouseEvent` был бы тип `any`, и ошибка бы не возникла.

Явное указание типа является более приоритетным, нежели контекстный тип.
```js
window.onmousedown = function(mouseEvent: any) {
    // mouseEvent: any
    console.log(mouseEvent.button);  //<- Now, no error is given
};
```

Контекстная типизация используется во многих случаях. Наиболее распространенные:
- аргументы вызова функций
- присваиваемые выражения (right hand sides of assignments)
- приведение к типу (type assertions)
- поля и свойства объектов и литералы массивов
- значение, возвращаемое функцией (return statements).

Также контекстный тип используется при явном указании “наиболее подходящего типа”, как в примере:
```js
function createZoo(): Animal[] {
    return [new Rhino(), new Elephant(), new Snake()];
}
```
В этом случае при попытке добавить в массив значение, которое не является производным типом от `Animal` компилятор выдаст сообщение об ошибке. И это все благодаря контекстной типизации.
