**Вывод типов** (англ. type inference) — возможность компилятора самому логически вывести тип значения у выражения.

Когда тип данных в явном виде не указан, в TypeScript используется автоматический вывод типа.
```js
let x = 3; // x будет иметь тип number.
```

Вывод типа происходит при:
- инициализации переменных
- установке значений по умолчанию
- определении типов возвращаемых функциями значений

В большинстве случаев вывод типа является очевидным и простым. Однако есть некоторые нюансы.

### Наиболее подходящий тип

Когда вывод типа осуществляется на основании нескольких выражений, типы этих выражений будут использоваться для вывода “наиболее подходящего типа” данных.

Рассмотрим пример:
```js
let x = [0, 1, null];
```

Алгоритм вывода наиболее подходящего типа для `x` учитывает тип каждого элемента в массиве и выбирает тип, совместимый со всеми элементами (`(number | null)[]`).

Поскольку наилучший общий тип необходимо выбрать из типов предоставленных элементов, возможна ситуация, когда у типов общая структура, но нет ни одного супер-типа, общего для всех.

```ts
let zoo = [new Rhino(), new Elephant(), new Snake()];
```

В идеале наилучшим общим типом был бы тип `Animal[]`, но элемента с таким типом нет в массиве. В этом случае, мы явно указываем тип:

```ts
let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];
```

Когда алгоритм не находит наилучший общий тип, используется union array type (`(Rhino | Elephant | Snake)[]`).


### Контекстуальная типизация

Когда тип выражения определяется его положением, происходит контекстуальная типизация.

```js
window.onmousedown = function(mouseEvent) {
    console.log(mouseEvent.button);  //<- Error
};
```

Для вывода типа функции после знака равенства используется тип функции `window.onmousedown`. При проверке типов произошел вывод типа параметра `mouseEvent`. Если бы функция не находилась в позиции контекстуальной типизации, у `mouseEvent` был бы тип `any`, и ошибка бы не возникла.

При явном указании типа контекстуальный тип игнорируется.
```js
window.onmousedown = function(mouseEvent: any) {
    console.log(mouseEvent.button);  //<- Now, no error is given
};
```

Контекстуальная типизация применяется во многих случаях. Наиболее частые:
- аргументы вызова функции (arguments to function calls)
- правая часть присваивания (right hand sides of assignments)
- type assertions
- члены литералов объекта или массива
- значение, возвращаемое функцией (return statements).

Контекстуальный тип также используется как кандидат в наиболее подходящие типы.
```js
function createZoo(): Animal[] {
    return [new Rhino(), new Elephant(), new Snake()];
}
```
В данном примере наиболее подходящий тип выбирается из `Animal`, `Rhino`, `Elephant` и `Snake`
