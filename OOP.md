# Объектно-ориентированное мышление

В качестве наглядного примера рассмотрим корпоративную систему и ее работников как объекты.

## Данные объектов
Данные, содержащиеся в объекте, представляют его состояние. В терминологии объектно-ориентированного программирования эти данные называются *атрибутами*.

Атрибутами работника могут быть номер социального страхования, дата рождения, пол.

## Поведения объектов
В терминологии ООП поведение объектов содержится в *методах*.
С помощью методов мы реализуют требуемое поведение класса, задаем и возвращаем значения атрибутов.

Допустим, для работника можно получить или задать пол с помощью `setGender()` и `getGender()`.

Мы показываем только интерфейс методов, а не реализацию.
Концепция геттеров и сеттеров поддерживает концепцию *скрытия данных*. Они обеспечивают управляемый доступ к данным объекта, поскольку другие объекты не должны напрямую
манипулировать данными.

## Классы
Можно сказать, что класс - это шаблон (или "чертёж"), на основе которого создаются объекты.
Класс определяет атрибуты и поведения, которые будут принадлежать всем объектам, созданным с использованием этого класса. Каждый объект будет содержать собственную копию атрибутов и методов.

### Модификаторы (обозначения) доступа
Тип данных или метод может быть определен как public, private или protected.
- **public** - у других объектов будет к нему прямой доступ.
- **private** - только конкретный объект сможет получить к нему доступ.
- **protected** - разрешает доступ с использованием связанных объектов

### Методы
Методы могут реализовывать поведения, вызываемые из других объектов (с помощью сообщений) либо обеспечивать основное, внутреннее поведение класса.

Доступ к атрибутам в объекте должен контролироваться самим этим объектом — никакие другие объекты не должны напрямую изменять значения атрибутов этого объекта.

### Сообщения
Сообщения — это механизм коммуникаций между объектами. Например, когда
объект А вызывает метод объекта В, объект А отправляет сообщение объекту В.
Ответ объекта В определяется его возвращаемым значением. Только открытые,
а не закрытые методы объекта могут вызываться другим объектом.

## Инкапсуляция и скрытие данных
Открытыми должны быть только те атрибуты и поведения объекта, с которыми небходмо взаимодействовать другим объектам.

**Инкапсуляция** - языковая конструкция, позволяющая связать данные с методами, предназначенными для обработки этих данных. Механизм языка, позволяющий ограничить доступ одних компонентов программы к другим.

Основу инкапсуляции составляют интерфейсы и реализация

### Атрибуты и скрытие данных
Для полной реализации скрытия данных атрибуты не должны являться частью интерфейсов и объявляются как private. Чтобы вернуть значение аттрибута используют геттер (метод). Таким образом, объект, содержащий аттрибут, будет управлять доступом к нему. Это важно для безопасности, тестирования и сопровождения.

### Интерфейс
Любое поведение должно вызываться через сообщение, отправленное с помощью интерфейса. Интерфейс - это набор методов данного объекта. Методы интерфейса определяются как public.

Интерфейс:
- добавляет уровень абстракции
- вызывается абстрактный метод и не нужно думать о его внутренней реализации
- может наследоваться и дополняться другими интерфейсами

### Реализация
Пользователь может взаимодействовать с объектом только через public интерфейс. Все остальное считается частью внутренней реализации и не должно быть доступным пользователю.

Реализация может меняться, однако это не должно влиять на интерфейс и пользовательский код.

Пример:
Тостер ("пользователь") - розетка (интерфейс) - электростанция (реализация - АЭС, ТЭС или что-то еще)

```java
public class IntSquare {
    // private attribute
    private int squareValue;
    // public interface
    public int getSquare (int value) {
        SquareValue =calculateSquare(value);
        return squareValue;
    }
    // private implementation
    private int calculateSquare (int value) {
        return value*value;
    }
}
```

## Наследование
- позволяет производным объектам наследовать атрибуты и методы родительского объекта
- помогает улучшить проектирование через выделение (абстрагирование) общих атрибутов и методов
- способствовует повторному использованию кода

Суперкласс (родитель)
Подкласс (или производный, или дочерний класс)

Производные классы могут изменять свойства, полученные от родителя:
- добавлять новые атрибуты и методы
    - не могут удалять атрибуты
- переопределять методы

Главные преимущества наследования - это абстрагирование и организация

### Абстрагирование
**Абстрагирование** означает выделение значимой информации и исключение из рассмотрения незначимой (для данного проекта).
- важна возможность переиспользования в будущем
    - абстракции помогают в работе со сложным
- Позволяет представить сложную реальность в виде упрощённой модели

### Отношения is-a («является экземпляром»)
Рассмотрим пример, в котором Circle, Square и Star наследуют от Shape. Это отношение часто называется отношением «является экземпляром», поскольку круг — это форма, как и квадрат. Когда подкласс наследует от суперкласса, он получает все возможности, которыми обладает этот суперкласс. Таким образом, Circle, Square и Star являются расширениями Shape.

## Полиморфизм
Полиморфизм означает, что схожие объекты способны по-разному отвечать на одно и то же сообщение.

В производных классах унаследованное поведение может быть переопределено
- Полиморфизм позволяет определять и вызвать абстрагированые методы
- Абстрагированые методы определяются в интерфейсе родительского класса, используется в производных классах и могут быть переопределны

Например, метод `getArea()` у `Shape`, `Rectangle` и `Circle` будет реализован по-разному.


## Композиция
Объекты зачастую состоят из других объектов — это и есть композиция.

Фактически, есть только два способа создания классов из других классов: наследование и композиция. Благодаря композиции мы к тому же можем создавать классы, вкладывая одни классы в другие (например, отношения has-a («содержит как часть») между автомобилем и двигателем).

### Отношения has-a («содержит как часть»)
Телевизор содержит как часть тюнер, а также экран





















## Cohesion

-   **Cohesion**  describes
    -   How closely the routines in a class or the code in a routine support a  **central purpose**
-   Cohesion must be  **strong**
    -   Well-defined abstractions keep cohesion strong
-   Classes must contain  **strongly related functionality**  and aim for single purpose
-   Cohesion is a powerful tool for managing complexity

### Good and Bad Cohesion

- **Good cohesion**: HDD, CR-ROM, remote control
- **Bad cohesion**: spaghetti code, single-board computer

### Strong Cohesion

-   **Strong cohesion**  (good cohesion) example
    -   Class  `Math`  that has methods:
        -   `Sin()`,  `Cos()`,  `Asin()`
        -   `Sqrt()`,  `Pow()`,  `Exp()`
        -   `Math.PI`,  `Math.E`

### Weak Cohesion

-   **Weak cohesion**  (bad cohesion) example
    -   Class  **Magic**  that has these methods:

```js
public void PrintDocument(Document d);
public void SendEmail(
string recipient, string subject, string text);
public void CalculateDistanceBetweenPoints(
int x1, int y1, int x2, int y2)
```
-   Another example:
```js
MagicClass.MakePizza("Fat Pepperoni");
MagicClass.WithdrawMoney("999e6");
MagicClass.OpenDBConnection();
```

## Связанность

-   **Связанность**  describes how tightly a class or routine is related to other classes or routines
-   Связанность must be kept  **loose**
    -   Modules must depend little on each other
        -   Or be entirely independent (**loosely coupled**)
    -   All classes / routines must have small, direct, visible, and flexible relationships to other classes / routines
    -   One module must be easily used by other modules

### Loose and Tight Связанность

-   **Loose Связанность**:
    -   Easily replace old HDD
    -   Easily place this HDD
        to another motherboard
- **Tight Связанность**:
	- Where is the video adapter?
	- Can you change the video controller?

## Spaghetti Code

-   Combination of bad cohesion and tight Связанность