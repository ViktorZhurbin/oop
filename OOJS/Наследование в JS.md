# Прототипно-ориентированная модель наследования

В классическом ООП:
- определяются классы
- создаются экземпляры объектов
  - все свойства и методы класса копируются в экземпляр

В JavaScript:
- определяются классы
- создаются экземпляры объектов
  - создается ссылка из экземпляра объекта на его прототип
    - свойства и методы не копируются
    - свойства и методы обнаруживаются путем подъема по цепи прототипов

В JavaScript каждый объект имеет внутреннюю ссылку на другой объект, называемый его прототипом. У объекта-прототипа также есть свой собственный прототип и так далее до тех пор, пока цепочка не завершится объектом, у которого свойство prototype равно null. По определению, null не имеет прототипа и является завершающим звеном в цепочке прототипов.



Прототип - это свойство __proto__, которое получено из свойства prototype в конструкторе.


## Наследование с цепочкой прототипов

https://developer.mozilla.org/ru/docs/Web/JavaScript/Inheritance_and_the_prototype_chain


### Наследование свойств

Объекты в JavaScript — динамические "контейнеры", наполненные свойствами (называемыми собственными свойствами). Каждый объект содержит ссылку на свой объект-прототип.

При попытке получить доступ к какому-либо свойству объекта, свойство вначале ищется в самом объекте, затем в прототипе объекта, после чего в прототипе прототипа, и так далее. Поиск ведется до тех пор, пока не найдено свойство с совпадающим именем или не достигнут конец цепочки прототипов.


### Заключение

При написании JavaScript-кода, использующего наследование, следует помнить о длине цепочек прототипов и стараться делать их как можно более короткими во избежание проблем с производительностью во время выполнения кода.

Расширять базовые прототипы следует исключительно для поддержания совместимости кода с отдельными "древними" реализациями JavaScript, - во всех прочих случаях это плохая практика.


## Наследование в ES5 и ES6

(https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance)

```js

// ES5
function Teacher(first, last, age, gender, interests, subject) {
  Person.call(this, first, last, age, gender, interests);

  this.subject = subject;
}

// ES6
class Teacher extends Person {
  constructor(first, last, age, gender, interests, subject, grade) {
    super(first, last, age, gender, interests);
    // subject and grade are specific to Teacher
    this.subject = subject;
    this.grade = grade;
  }
}
```
