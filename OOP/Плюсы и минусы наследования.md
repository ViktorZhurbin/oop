## Наследование

**Плюсы**:
- помогает выделять (абстрагировать) общие свойства
  - позволяет использовать полиморфизм
  - способствовует повторному использованию кода
- улучшает организацию кода и проектирование

**Минусы**:
- наследуются все свойства родителя
  - не зависимо от того, нужны или ненужны они в конкретном случае
  - нужно хорошо знать родительский класс
- сильная (внешняя) связанность подклассов
- невозможно предусмотреть все будущие случаи использования
  - со временем новые случаи использования трудно вписать в иерархию дерева наследования
  - возникает необходимость дублировать код
- проблема хрупкого базового класса
  - чем больше у суперкласса подклассов, тем вероятнее, что малейшие правки в реализации базового класса привнесут ошибку в подклассах


### Как наследование ослабляет инкапсуляцию

Подкласс использует реализацию по крайней мере части свойств суперкласса. Изменение реализации суперкласса распространяется по иерархии на подклассы. Это усиливает внешнюю связанность и может ослабить инкапсуляцию и усложить тестирование.

При использовании наследования важно придерживаться строгого условия "является" (is-a), то есть является конкретизацией суперкласса.

Если класс Circle унаследует реализацию от класса Shape, а изменение реализации Shape нарушит Circle, то отношения между ними не являются отношением "является".


## Примеры

**"Горилла с бананом"**
```js
GameObject
  .bark()

    Robot
      .drive()

      CleaningRobot
        .clean()

      MurderRobot
        .kill()

        MurderRobotDog
          ~~.bark()~~

    Animal
      .poop()

        Dog
          ~~.bark()~~

        Cat
          .meow()
```

**То же через композицию**

```js
const barker = (state) => ({
  bark: () => console.log('Woof, I am ' + state.name)
})
const driver = (state) => ({
  drive: () => state.position = state.position + state.speed
})

const murderRobotDog = (name)  => {
  let state = {
    name,
    speed: 100,
    position: 0
  }
  return Object.assign(
        {},
        barker(state),
        driver(state),
        killer(state)
    )
}
const bruno =  murderRobotDog('bruno')
bruno.bark() // "Woof, I am Bruno"
```