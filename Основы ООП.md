## Инкапсуляция

Один из главных принципов ООП - деление программ на части, каждая из которых отвечает только за то, что происходит внутри неё. Реализуется этот принцип через объекты.

При таком подходе нет необходимости помнить и знать, как та или иная часть программы устроена внутри. Если реализация (=код) одной части изменится, другие менять не придется.

В общем случае в разных языках программирования термин «инкапсуляция» относится к одному или обоим одновременно следующим определениям:

1) позволяет связать данные с методами, предназначенными для обработки этих данных;
ЗАЧЕМ объединять методы и данные в одном объекте?
2) позволяет ограничить доступ одних компонентов программы к другим;

Открытыми должны быть только те атрибуты и методы объекта, с которыми небходмо взаимодействовать другим объектам.

Основу инкапсуляции составляют интерфейсы и реализация


### Интерфейс

Любое поведение должно вызываться через сообщение, отправленное с помощью интерфейса. Интерфейс - это набор методов данного объекта. Методы интерфейса определяются как public.

Интерфейс:
- добавляет уровень абстракции
- вызывается абстрактный метод и не нужно думать о его внутренней реализации
- может наследоваться и дополняться другими интерфейсами


### Реализация

Пользователь может взаимодействовать с объектом только через public интерфейс. Все остальное считается частью внутренней реализации и не должно быть доступным пользователю.

Реализация может меняться, однако это не должно влиять на интерфейс и пользовательский код.

Пример:
Тостер ("пользователь") - розетка (интерфейс) - электростанция (реализация - АЭС, ТЭС или что-то еще)

```java
public class IntSquare {
    // private attribute
    private int squareValue;
    // public interface
    public int getSquare (int value) {
        SquareValue =calculateSquare(value);
        return squareValue;
    }
    // private implementation
    private int calculateSquare (int value) {
        return value*value;
    }
}
```


## Наследование

- позволяет производным объектам наследовать атрибуты и методы родительского объекта
- помогает улучшить проектирование через выделение (абстрагирование) общих атрибутов и методов
- способствовует повторному использованию кода

Суперкласс (родитель)
Подкласс (или производный, или дочерний класс)

Производные классы могут изменять свойства, полученные от родителя:
- добавлять новые атрибуты и методы
    - не могут удалять атрибуты
- переопределять методы

Главные преимущества наследования - это абстрагирование и организация


### Абстрагирование

**Абстрагирование** означает выделение значимой информации и исключение из рассмотрения незначимой (для данного проекта).
- важна возможность переиспользования в будущем
    - абстракции помогают в работе со сложным
- Позволяет представить сложную реальность в виде упрощённой модели


### Отношения is-a («является экземпляром»)

Рассмотрим пример, в котором Circle, Square и Star наследуют от Shape. Это отношение часто называется отношением «является экземпляром», поскольку круг — это форма, как и квадрат. Когда подкласс наследует от суперкласса, он получает все возможности, которыми обладает этот суперкласс. Таким образом, Circle, Square и Star являются расширениями Shape.


## Полиморфизм

Полиморфизм означает, что схожие объекты способны по-разному отвечать на одно и то же сообщение.

В производных классах унаследованное поведение может быть переопределено
- Полиморфизм позволяет определять и вызвать абстрагированые методы
- Абстрагированые методы определяются в интерфейсе родительского класса, используется в производных классах и могут быть переопределны

Например, метод `getArea()` у `Shape`, `Rectangle` и `Circle` будет реализован по-разному.


## Композиция

Объекты зачастую состоят из других объектов — это и есть композиция.

Фактически, есть только два способа создания классов из других классов: наследование и композиция. Благодаря композиции мы к тому же можем создавать классы, вкладывая одни классы в другие (например, отношения has-a («содержит как часть») между автомобилем и двигателем).


### Отношения has-a («содержит как часть»)

Телевизор содержит как часть тюнер, а также экран


## Связность

Связность характеризует то, насколько хорошо все методы класса или все фрагменты метода соответствуют главной цели

Сильная связность
    - Хорошо определенные абстракции помогают повысить связность
-   Classes must contain  **strongly related functionality**  and aim for single purpose
-   Cohesion is a powerful tool for managing complexity


### Сильная связность

- Class  `Math`  that has methods:
    - `Sin()`,  `Cos()`,  `Asin()`
    - `Sqrt()`,  `Pow()`,  `Exp()`
    - `Math.PI`,  `Math.E`


### Слабая связность

- Class  **Magic**  that has these methods:

```java
public void PrintDocument(Document d);
public void SendEmail(
string recipient, string subject, string text);
public void CalculateDistanceBetweenPoints(
int x1, int y1, int x2, int y2)
```
- Another example:
```java
MagicClass.MakePizza("Fat Pepperoni");
MagicClass.WithdrawMoney("999e6");
MagicClass.OpenDBConnection();
```


## Зацепление

Зацепление - это степень зависимости классов друг от друга
- Зацепление лучше понижать
    - прямая, видимая и гибкая связь с другими классами предпочтительна
    - модуль должно быть легко использовать с другими модулями
    - модули должны слабо зависеть друг от друга или быть независимыми

- Слабое зацепление:
    - Easily replace old HDD
    - Easily place this HDD to another motherboard
- Сильное зацепление:
	- Where is the video adapter?
	- Can you change the video controller?

## Код-лапша
Комбинация слабой связности и сильного зацепления.
