[x] http://sergeyteplyakov.blogspot.com/2014/10/solid.html
[] http://sergeyteplyakov.blogspot.com/2014/08/single-responsibility-principle.html
[] https://blog.byndyu.ru/2009/10/solid.html


## S – Single Responsibility Principle
Принцип единственной ответственности.


### Определение
У класса/модуля должна быть лишь одна причина для изменения.


### Смысл принципа
Борьба со сложностью, важность которой резко возрастает при развитии логики приложения.


### Краткое описание
Любой сложный класс должен быть разбит на несколько простых составляющих, отвечающих за определенный аспект поведения. Это упрощает как понимание, так и будущее развитие.


### Типовые примеры нарушения
1) смешивание логики и инфраструктуры (например, бизнес-логика смешана с представлением)
2) класс/модуль решает задачи разных уровней абстракции (разбирает json-объект и анализирует его содержимое)


### Anti-SRP
Принцип размытой ответственности. Чрезмерная любовь к SRP ведет к обилию мелких классов/методов и размазыванию логики между ними.


## O – Open-Closed Principle
Принцип открытости-закрытости


### Определение
Программные сущности (классы, модули, функции и т.п.) должны быть открытыми для расширения, но закрытыми для модификации. То есть, должна быть возможность расширить/изменить поведение системы без изменения/переписывания уже существующих частей системы.


### Смысл
Ограничить распространение изменений минимальным числом классов/модулей; позволить вести параллельную разработку путем фиксации интерфейсов классов и открытости реализаций.


### Краткое описание
Закрытость модулей означает стабильность интерфейса и возможность использования классов/модулей клиентами.

Открытость модулей означает возможность внесения изменений в поведении, путем изменения реализации или же путем переопределения поведения в наследниках.

Борьба с изменениями заключается в ограничении количества изменений минимальным числом классов/модулей и не подразумевает возможность изменения поведения без перекомпиляции. На практике требуемая «гибкость» обеспечивается за счет наследования и сопоставления с образцом (pattern matching), в зависимости от того, какую операцию мы хотим упростить – добавление нового подтипа в иерархию наследования или добавление новой операции в семейство типов.


### Типичные примеры нарушения
Размазывание информации об иерархии типов по всему приложению.


### Anti-OCP – Принцип фабрики-фабрик
Чрезмерная любовь к OCP ведет к переусложненным решениям с чрезмерным числом уровней абстракции.


## L – Liskov Substitution Principle
Принцип замещения Барбары Лисков


### Определение
Должна быть возможность вместо базового типа подставить любой его подтип.


### Смысл
Принцип подстановки Лисков призван помочь в корректной реализации наследования, что также должно помочь отказаться от наследования, если его корректная реализация невозможна.

Расширение класса не должно нарушать работу приложения или создавать фатальные ошибки для всего приложения.


### Краткое описание
Для корректной реализации отношения "является", наследники:
1) не должны требовать большего от своих клиентов (сохранять или ослаблять предусловие)
2) должны гарантировать как минимум то же, что и базовый класс (сохранять или усиливать постусловие).
3) При этом инварианты базового класса должны выполняться наследником.
4) Производные классы не должны генерировать исключения, не описанные базовым классом.

При нарушении этих правил подстановка экземпляров наследника в метод, принимающий базовый класс будет приводить к непредсказуемым последствиям.


### Типичные примеры нарушения
Несогласованное поведение наследников, что приводит к необходимости приводить экземпляры базового класса к конкретным типам наследников.

### Anti-LSP
Принцип непонятного наследования. Данный анти-принцип проявляется либо в чрезмерном количестве наследования, либо в его полном отсутствии, в зависимости от опыта и взглядов местного главного архитектора


## I - Interface Segregation Principle
Принцип разделения интерфейсов


### Определение
Клиенты не должны вынужденно зависеть от методов, которыми не пользуются.


### Смысл
Класс должен предоставлять удобный интерфейс с точки зрения его разнообразных клиентов.


### Краткое описание
Интерфейс класса должен быть цельным и согласованным не зависимо от числа клиентов. Несколько разных клиентов вполне могут использовать лишь подмножество методов класса, до тех пор, пока интерфейс класса будет оставаться согласованным. Проблемы появляются тогда, когда интерфейс класса начинает распухать или появляются разные методы с похожей семантикой лишь для того, чтобы ими было удобно пользоваться определенным клиентам.


### Типичные примеры нарушения
1) класс или интерфейс содержит несколько методов со схожей семантикой, которые используются разными клиентами;
2) интерфейс класса слишком разнороден и содержит методы, отвечающие за слабосвязанные операции.

### Anti-ISP
Принцип тысячи интерфейсов. Интерфейсы классов разбиваются на слишком большое число составляющих, что делает их неудобными для использования всеми клиентами.


## D – Dependency Inversion Principle
Принцип инверсии зависимостей


### Определение
Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те и другие должны зависеть от абстракций.


### Смысл
Сделать ключевые и/или изменчивые зависимости класса явными.


### Краткое описание
Слишком большое число зависимостей класса говорит о проблемах в дизайне. Возможно класс делает слишком многое, или же текущий класс не удачен, что приводит к необходимости дергания по одному методу у слишком большого числа зависимостей.

Любой объектный дизайн представляет собой некоторый граф взаимодействующих объектов, при этом некоторые зависимости являются частью реализации и должны создаваться напрямую (композиция), а некоторые – передаваться ему извне (агрегация). Выделять зависимости особенно полезно, когда они являются изменчивыми (завязаны на окружения), или же представляют собой некоторую форму «стратегий».

Зависимости внутри системы строятся на основе абстракций. Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Модули должны быть автономными и должны соединяться с помощью абстракции.


### Типичные примеры нарушения
Использование синглтонов, сервис-локаторов или же создание ключевых зависимостей класса по ходу дела в закрытых методах.

### Anti-DIP
Принцип инверсии сознания или DI-головного мозга. Интерфейсы выделяются для каждого класса и пачками передаются через конструкторы. Понять, где находится логика становится практически невозможно.
